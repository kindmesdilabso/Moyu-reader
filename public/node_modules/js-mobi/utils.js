"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.binarySearch = exports.combineUint8array = exports.isVideRecord = exports.isAudiRecord = exports.isCmetRecord = exports.isSrcsRecord = exports.isDatpRecord = exports.isFdstRecord = exports.isFcisRecord = exports.isFlisRecord = exports.isTagxRecord = exports.isIndexRecord = exports.isImage = exports.isOfTypeAtOffset = exports.isCover = exports.isThumbnail = exports.startsWith = exports.isEndOfTextRecord = exports.isContentRecord = void 0;
var EXTHRecord_1 = require("js-mobi/EXTHRecord");
function isContentRecord(palmHeader, index) {
    return index >= 1 && index <= palmHeader.recordCount;
}
exports.isContentRecord = isContentRecord;
/**
 * In some cases, there are a 2-zero-byte record after the text records in a file.
 */
function isEndOfTextRecord(palmHeader, index, content) {
    return (palmHeader.recordCount + 1 === index && content.length === 2 && startsWith(content, new Uint8Array([0x00, 0x00])));
}
exports.isEndOfTextRecord = isEndOfTextRecord;
function startsWith(a, b) {
    if (a.length >= b.length) {
        for (var i = 0; i < b.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    return false;
}
exports.startsWith = startsWith;
function isThumbnail(mobiHeader, index) {
    return isOfTypeAtOffset(mobiHeader, EXTHRecord_1.EXTHRecordType.THUMBNAIL_OFFSET, index);
}
exports.isThumbnail = isThumbnail;
function isCover(mobiHeader, index) {
    return isOfTypeAtOffset(mobiHeader, EXTHRecord_1.EXTHRecordType.COVER_OFFSET, index);
}
exports.isCover = isCover;
function isOfTypeAtOffset(mobiHeader, type, index) {
    var exthRecords = mobiHeader.getEXTHRecords(type);
    for (var _i = 0, exthRecords_1 = exthRecords; _i < exthRecords_1.length; _i++) {
        var exthRecord = exthRecords_1[_i];
        if (mobiHeader.firstImageIndex + exthRecord.getIntData() === index) {
            return true;
        }
    }
    return false;
}
exports.isOfTypeAtOffset = isOfTypeAtOffset;
/**
 * Tries to guess what the image type (if any) of a file based on the file's "magic numbers," the first bytes of the file.
 *
 * @param data byte array to be tested for image data.
 * @return <code>true</code> if an image was detected and <code>false</code> otherwise.
 */
function isImage(uint8) {
    var data = new DataView(uint8.buffer);
    if (data.byteLength > 4) {
        var b1 = data.getUint8(0);
        var b2 = data.getUint8(1);
        var b3 = data.getUint8(2);
        var b4 = data.getUint8(3);
        if (b1 === 0x47 && b2 === 0x49) {
            return true; // image/gif
        }
        else if (b1 === 0x89 && b2 === 0x50) {
            return true; // image/png
        }
        else if (b1 === 0xff && b2 === 0xd8) {
            return true; // image/jpeg
        }
        else if (b1 === 0xff && b2 === 0xd9) {
            return true; // image/jpeg
        }
        else if (b1 === 0x42 && b2 === 0x4d) {
            return true; // image/bmp
        }
        else if (b1 === 0x4d && b2 === 0x4d) {
            return true; // Motorola byte order TIFF
        }
        else if (b1 === 0x49 && b2 === 0x49) {
            return true; // Intel byte order TIFF
        }
        else if (b1 === 0x38 && b2 === 0x42) {
            return true; // image/psd
        }
        else if (b1 === 0x50 && b2 === 0x31) {
            return true; // image/pbm
        }
        else if (b1 === 0x50 && b2 === 0x34) {
            return true; // image/pbm
        }
        else if (b1 === 0x50 && b2 === 0x32) {
            return true; // image/pgm
        }
        else if (b1 === 0x50 && b2 === 0x35) {
            return true; // image/pgm
        }
        else if (b1 === 0x50 && b2 === 0x33) {
            return true; // image/pgm
        }
        else if (b1 === 0x50 && b2 === 0x36) {
            return true; // image/pgm
        }
        else if (b1 === 0x97 && b2 === 0x4a && b3 === 0x42 && b4 === 0x32) {
            return true; // image/x-jbig2
        }
    }
    return false;
}
exports.isImage = isImage;
/**
 * Book index record which contains the meta data of the index.
 */
function isIndexRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('INDX'));
}
exports.isIndexRecord = isIndexRecord;
function isTagxRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('TAGX'));
}
exports.isTagxRecord = isTagxRecord;
function isFlisRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('FLIS'));
}
exports.isFlisRecord = isFlisRecord;
function isFcisRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('FCIS'));
}
exports.isFcisRecord = isFcisRecord;
function isFdstRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('FDST'));
}
exports.isFdstRecord = isFdstRecord;
function isDatpRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('DATP'));
}
exports.isDatpRecord = isDatpRecord;
/**
 * A SRCS record is a record whose content is a zip archive of all source files (i.e., .opf, .ncx, .htm, .jpg, ...)
 */
function isSrcsRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('SRCS'));
}
exports.isSrcsRecord = isSrcsRecord;
/**
 * A CMET record is a record whose content is the output of the compilation operation, and perhaps extra info.
 */
function isCmetRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('CMET'));
}
exports.isCmetRecord = isCmetRecord;
/**
 * kindlegen supports embedded audio and video for some Kindle platforms. Each media file is stored in a separate AUDI (audio) or VIDE
 * (video) record
 */
function isAudiRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('AUDI'));
}
exports.isAudiRecord = isAudiRecord;
/**
 * kindlegen supports embedded audio and video for some Kindle platforms. Each media file is stored in a separate AUDI (audio) or VIDE
 * (video) record
 */
function isVideRecord(content) {
    var utf8encoder = new TextEncoder();
    return startsWith(content, utf8encoder.encode('VIDE'));
}
exports.isVideRecord = isVideRecord;
function combineUint8array(buffers) {
    var totalSize = 0;
    for (var i = 0; i < buffers.length; i++) {
        var buffer = buffers[i];
        totalSize += buffer.length;
    }
    var totalBuffer = new Uint8Array(totalSize);
    var offset = 0;
    for (var i = 0; i < buffers.length; i++) {
        var buffer = buffers[i];
        totalBuffer.set(buffer, offset);
        offset += buffer.length;
    }
    return totalBuffer;
}
exports.combineUint8array = combineUint8array;
function binarySearch(arr, val) {
    var low = 0;
    var high = arr.length - 1;
    while (low <= high) {
        var mid = (low + high) >>> 1;
        var midVal = arr[mid];
        if (midVal < val) {
            low = mid + 1;
        }
        else if (midVal > val) {
            high = mid - 1;
        }
        else {
            return mid; // key found
        }
    }
    return -(low + 1); // key not found.
}
exports.binarySearch = binarySearch;
//# sourceMappingURL=utils.js.map